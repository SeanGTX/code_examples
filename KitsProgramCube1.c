#pragma config(Sensor, S1,     SensorRight,    sensorEV3_Color)
#pragma config(Sensor, S2,     CrossSensor,    sensorEV3_Color)
#pragma config(Sensor, S3,     SensorLeft,     sensorEV3_Color)
#pragma config(Motor,  motorA,          MotorR,        tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,          MotorL,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int lasterr = 0, counterr, speed = 50, maxR = 0, maxL = 0, minR = 101, minL = 101;
float err = 0;

void PIDreg ()
{
	float Pn = 0.01, Dn = 0.6, In = 0.3,IIn = 0.5;
	counterr = getColorReflected(SensorLeft) - getColorReflected(SensorRight);
	err = IIn * (0.5 * err + counterr);
	motor[MotorL] = speed + counterr * Pn + err * In + (counterr - lasterr) * Dn;
	motor[MotorR] = speed - counterr * Pn - err * In - (counterr - lasterr) * Dn;
	lasterr = counterr;
}

void CrossForward()
{
	resetMotorEncoder(MotorL);
	while (nMotorEncoder[MotorL] < 379) PIDreg();
}

void TurnLeft270()
{
	motor[MotorL] = 0;
	motor[MotorR] = 0;
	resetMotorEncoder(MotorR);
	while (nMotorEncoder[MotorR] < 90)
	{
		motor[MotorR] = 40;
		motor[MotorL] = -40;

	}
	while (getColorReflected(SensorLeft) > 30)
	{
		motor[MotorR] = 40;
		motor[MotorL] = -40;
	}
	while (getColorReflected(SensorLeft) < 35)
	{
		motor[MotorR] = 40;
		motor[MotorL] = -40;
	}
	motor[MotorL] = 0;
	motor[MotorR] = 0;
}

void TurnRight270()
{
	motor[MotorL] = 0;
	motor[MotorR] = 0;
	resetMotorEncoder(MotorL);
	while (nMotorEncoder[MotorL] < 90)
	{
		motor[MotorL] = 40;
		motor[MotorR] = -40;
	}
	while (getColorReflected(SensorRight) > 44)
	{
		motor[MotorL] = 40;
		motor[MotorR] = -40;
	}
	motor[MotorL] = 0;
	motor[MotorR] = 0;
	while (getColorReflected(SensorRight) < 49)
	{

		motor[MotorL] = 40;
		motor[MotorR] = -40;
	}
	motor[MotorL] = 0;
	motor[MotorR] = 0;
}
void GoToCross()
{
	while (getColorReflected(CrossSensor) > 22) PIDreg();
	motor[MotorL] = 0;
	motor[MotorR] = 0;
	playImmediateTone(800,20);
	CrossForward();
}

/*
y = 1 , x = 2 , -y = 3 , -x = 4
Cubes[8] = {2,3,1,0,3,1,1,0} {1,2,3,2,0,2,1,1}
snake - Cubes[28] = {3,0,3,1,0,1,0,2,3,2,3,3,0,3,3,3,3,2,0,2,0,1,3,1,3,0,0,0}
circle - Cubes[8] = {0,3,3,3,3,0,0,0}
arc - Cubes[] = {0,3,3,3,3,0,3,3,0,3,0,0}
diagonal - Cubes[24] = {1,0,1,1,2,1,2,2,3,2,3,3,3,2,2,2,2,1,1,1,1,0,0,0}*/
int Cubes[28] = {3,0,3,1,0,1,0,2,3,2,3,3,0,3,3,3,3,2,0,2,0,1,3,1,3,0,0,0}, x = 0, y = 0, Current_X = 0, Current_Y = 0,direction = 1,i=0;

task main()
{

	for(i = 0;i < 27;i = i + 2)
	{
		x = Cubes[i];
		if (Current_X < x)
		{
			if (direction == 1)	TurnRight270();
			if (direction == 3)	TurnLeft270();
			if (direction == 4)
			{
				TurnLeft270();
				TurnLeft270();
			}
			direction = 2;
			while (Current_X < x)
			{
			GoToCross();
			Current_X++;
			}
		}
		if (Current_X > x)
		{
			if (direction == 1)	TurnLeft270();
			if (direction == 2)
			{
				TurnLeft270();
				TurnLeft270();
			}
			if (direction == 3) TurnRight270();
			direction = 4;
			while (Current_X > x)
			{
				GoToCross();
				Current_X--;
			}
		}
		motor[MotorL] = 0;
	  motor[MotorR] = 0;
	  delay(100);
		y = Cubes[i + 1];
		if (Current_Y < y)
		{
			if (direction == 2) TurnLeft270();
			if (direction == 3)
			{
				TurnLeft270();
				TurnLeft270();
			}
			if (direction == 4) TurnRight270();
			direction = 1;
			while (Current_Y < y)
			{
				GoToCross();
				Current_Y++;
			}
		}
		if (Current_Y > y)
		{
			if (direction == 1)
			{
				TurnLeft270();
				TurnLeft270();
			}
			if (direction == 2) TurnRight270();
			if (direction == 4) TurnLeft270();
			direction = 3;
				while (Current_Y > y)
			{
				GoToCross();
				Current_Y--;
			}
		}
		motor[MotorL] = 0;
	  motor[MotorR] = 0;
	}
	if ((Current_X == 0) && (Current_Y == 0))
	if (direction == 3)
	{
		TurnRight270();
		TurnRight270();
	}
	else TurnRight270();
	playTone(300,50);
}
